---
globs: **/config*.rs,**/*config*.rs
alwaysApply: false
---

# Configuration Management Standards for DaemonEye

## Configuration Architecture

DaemonEye uses hierarchical configuration with multiple sources:

1. **Command-line flags** (highest precedence)
2. **Environment variables** (`PROCMOND_*`, `DAEMONEYE_*`)
3. **User configuration file** (`~/.config/daemoneye/config.yaml`)
4. **System configuration file** (`/etc/daemoneye/config.yaml`)
5. **Embedded defaults** (lowest precedence)

## Configuration Structure

Define configuration using serde with validation:

```rust
use serde::{Deserialize, Serialize};
use std::time::Duration;
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub scan_interval_ms: u64,
    pub batch_size: usize,
    pub log_level: String,
    pub debug_logging: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseConfig {
    pub path: PathBuf,
    pub max_connections: u32,
    pub retention_days: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertingConfig {
    pub enabled: bool,
    pub sinks: Vec<AlertSinkConfig>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertSinkConfig {
    pub sink_type: String,
    pub endpoint: Option<String>,
    pub facility: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub app: AppConfig,
    pub database: DatabaseConfig,
    pub alerting: AlertingConfig,
}
```

## Configuration Loading

Implement hierarchical configuration loading:

```rust
use figment::{Figment, providers::{Format, Yaml, Toml, Env}};
use std::path::Path;

impl Config {
    pub fn load() -> Result<Self, ConfigError> {
        let config = Figment::new()
            // Embedded defaults
            .merge(Config::default())
            // System configuration
            .merge(Yaml::file("/etc/daemoneye/config.yaml"))
            // User configuration
            .merge(Yaml::file("~/.config/daemoneye/config.yaml"))
            // Environment variables
            .merge(Env::prefixed("DAEMONEYE_"))
            // Command line arguments (if provided)
            .extract()?;

        config.validate()?;
        Ok(config)
    }

    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, ConfigError> {
        let config = Figment::new()
            .merge(Config::default())
            .merge(Yaml::file(path))
            .merge(Env::prefixed("DAEMONEYE_"))
            .extract()?;

        config.validate()?;
        Ok(config)
    }
}
```

## Configuration Validation

Implement comprehensive validation:

```rust
impl Config {
    pub fn validate(&self) -> Result<(), ConfigError> {
        // Validate scan interval
        if self.app.scan_interval_ms < 1000 {
            return Err(ConfigError::InvalidScanInterval(self.app.scan_interval_ms));
        }

        // Validate batch size
        if self.app.batch_size == 0 || self.app.batch_size > 10000 {
            return Err(ConfigError::InvalidBatchSize(self.app.batch_size));
        }

        // Validate log level
        let valid_levels = ["trace", "debug", "info", "warn", "error"];
        if !valid_levels.contains(&self.app.log_level.as_str()) {
            return Err(ConfigError::InvalidLogLevel(self.app.log_level.clone()));
        }

        // Validate database path
        if let Some(parent) = self.database.path.parent() {
            if !parent.exists() {
                return Err(ConfigError::DatabasePathNotFound(self.database.path.clone()));
            }
        }

        // Validate alerting configuration
        if self.alerting.enabled {
            if self.alerting.sinks.is_empty() {
                return Err(ConfigError::NoAlertSinksConfigured);
            }

            for sink in &self.alerting.sinks {
                sink.validate()?;
            }
        }

        Ok(())
    }
}

#[derive(Debug, thiserror::Error)]
pub enum ConfigError {
    #[error("Invalid scan interval: {0}ms (minimum 1000ms)")]
    InvalidScanInterval(u64),

    #[error("Invalid batch size: {0} (must be 1-10000)")]
    InvalidBatchSize(usize),

    #[error("Invalid log level: {0} (must be trace, debug, info, warn, or error)")]
    InvalidLogLevel(String),

    #[error("Database path not found: {0}")]
    DatabasePathNotFound(PathBuf),

    #[error("No alert sinks configured")]
    NoAlertSinksConfigured,
}
```

## Environment Variable Mapping

Map environment variables to configuration:

```rust
// Environment variables map to nested config:
// DAEMONEYE_APP_SCAN_INTERVAL_MS=5000
// DAEMONEYE_DATABASE_PATH=/var/lib/daemoneye/data.db
// DAEMONEYE_ALERTING_ENABLED=true

impl Default for Config {
    fn default() -> Self {
        Self {
            app: AppConfig {
                scan_interval_ms: 30000,
                batch_size: 1000,
                log_level: "info".to_string(),
                debug_logging: false,
            },
            database: DatabaseConfig {
                path: PathBuf::from("/var/lib/daemoneye/processes.db"),
                max_connections: 10,
                retention_days: 30,
            },
            alerting: AlertingConfig {
                enabled: false,
                sinks: vec![],
            },
        }
    }
}
```

## Configuration Testing

Test configuration loading and validation:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_default_config() {
        let config = Config::default();
        assert_eq!(config.app.scan_interval_ms, 30000);
        assert_eq!(config.app.batch_size, 1000);
        assert_eq!(config.app.log_level, "info");
    }

    #[test]
    fn test_config_validation() {
        let mut config = Config::default();
        config.app.scan_interval_ms = 500; // Invalid: too low
        
        assert!(config.validate().is_err());
    }

    #[test]
    fn test_config_loading_from_file() {
        let temp_dir = TempDir::new().unwrap();
        let config_path = temp_dir.path().join("config.yaml");
        
        let yaml = r#"
app:
  scan_interval_ms: 10000
  batch_size: 500
  log_level: debug
database:
  path: /tmp/test.db
  max_connections: 5
  retention_days: 7
alerting:
  enabled: false
  sinks: []
"#;
        
        std::fs::write(&config_path, yaml).unwrap();
        
        let config = Config::load_from_file(&config_path).unwrap();
        assert_eq!(config.app.scan_interval_ms, 10000);
        assert_eq!(config.app.batch_size, 500);
        assert_eq!(config.app.log_level, "debug");
    }

    #[test]
    fn test_environment_variable_override() {
        std::env::set_var("DAEMONEYE_APP_SCAN_INTERVAL_MS", "15000");
        std::env::set_var("DAEMONEYE_APP_LOG_LEVEL", "debug");
        
        let config = Config::load().unwrap();
        assert_eq!(config.app.scan_interval_ms, 15000);
        assert_eq!(config.app.log_level, "debug");
        
        // Cleanup
        std::env::remove_var("DAEMONEYE_APP_SCAN_INTERVAL_MS");
        std::env::remove_var("DAEMONEYE_APP_LOG_LEVEL");
    }
}
```

## Configuration Documentation

Document configuration options:

```rust
/// DaemonEye configuration structure.
///
/// Configuration is loaded from multiple sources in order of precedence:
/// 1. Command-line arguments (highest)
/// 2. Environment variables (`DAEMONEYE_*`)
/// 3. User config file (`~/.config/daemoneye/config.yaml`)
/// 4. System config file (`/etc/daemoneye/config.yaml`)
/// 5. Embedded defaults (lowest)
///
/// # Example Configuration
///
/// ```yaml
/// app:
///   scan_interval_ms: 30000
///   batch_size: 1000
///   log_level: info
///   debug_logging: false
///
/// database:
///   path: /var/lib/daemoneye/processes.db
///   max_connections: 10
///   retention_days: 30
///
/// alerting:
///   enabled: true
///   sinks:
///     - sink_type: syslog
///       facility: daemon
///     - sink_type: webhook
///       endpoint: https://alerts.example.com/api
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    // ... fields
}
```
